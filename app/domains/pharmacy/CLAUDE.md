# CLAUDE.md - Pharmacy Domain

Guidance for Claude Code working with the Pharmacy domain.

## Domain Overview

**Pharmacy Domain** - Healthcare pharmacy operations management within Aynux multi-domain platform.

| Feature | Description |
|---------|-------------|
| **Architecture** | Clean Architecture + DDD |
| **Agent** | `pharmacy_operations_agent` |
| **Domain Key** | `pharmacy` |

## Chatbot Flow Specification

**IMPORTANTE**: El flujo completo del chatbot de farmacia est√° documentado en:

üìÑ **`docs/pharmacy_flujo_mejorado_v2.md`**

Este documento define:

| Secci√≥n | Contenido |
|---------|-----------|
| **Arquitectura** | Diagrama de flujo entry point ‚Üí validaciones ‚Üí men√∫ ‚Üí acciones |
| **CASO 0** | Validaciones de entrada (deduplicaci√≥n, rate limiting, horario) |
| **CASO 1-2** | Identificaci√≥n de usuarios y navegaci√≥n del men√∫ principal |
| **CASO 3-4** | Consulta de deuda y flujo de pago (total/parcial) |
| **CASO 5** | Webhook Mercado Pago y notificaciones |
| **CASO 6-8** | Info farmacia, historial pagos, centro de ayuda |
| **CASO 9-10** | Gesti√≥n de m√∫ltiples personas y registro |
| **CASO 11-12** | Salir/despedida y manejo fuera de alcance |
| **Interrupciones** | Keywords globales (MENU, AYUDA, CANCELAR, SALIR, HUMANO) |
| **Estados** | PharmacyState TypedDict con 50+ campos |
| **Templates** | Plantillas YAML para mensajes |

**Reglas de Implementaci√≥n**:
1. Cada CASO del documento corresponde a uno o m√°s nodos en `agents/nodes/`
2. Los estados del sistema se definen en `agents/state.py` (PharmacyState)
3. El flujo se orquesta via `agents/routing/router.py` y `agents/graph.py`
4. Las respuestas usan `PharmacyResponseGenerator` con config desde DB
5. Consultar SIEMPRE el documento antes de modificar flujos

## Critical Development Rules

### 1. Exception Handling - Always preserve stack traces
```python
# ‚úÖ Good
except ValueError as e:
    raise HTTPException(status_code=400, detail="Invalid") from e
```

### 2. Modern Typing (Python 3.10+)
```python
# ‚úÖ Use native types
def func(ids: list[int], data: dict[str, str] | None) -> None: ...
# ‚ùå Avoid: List, Dict, Optional from typing
```

### 3. UTC Timezone
```python
from datetime import UTC, datetime
now = datetime.now(UTC)  # ‚úÖ Always UTC
```

### 4. pgvector with asyncpg - CRITICAL Bug
When using SQLAlchemy `text()` with asyncpg and pgvector, **NEVER use `::vector` cast syntax** with named parameters:

```python
# ‚ùå BROKEN - asyncpg confuses :param::type syntax
sql = text("SELECT * FROM docs WHERE 1 - (embedding <=> :vec::vector) > 0.5")

# ‚úÖ CORRECT - use CAST() instead
sql = text("SELECT * FROM docs WHERE 1 - (embedding <=> CAST(:vec AS vector)) > 0.5")
```

**Why**: asyncpg interprets `:vec` as a parameter placeholder, then `::vector` causes a syntax error.

### 5. Response Generation - PharmacyResponseGenerator

All responses use `PharmacyResponseGenerator` which provides LLM-driven responses with database-driven configuration.

**Architecture**:
| Component | Purpose |
|-----------|---------|
| `core.response_configs` | Database table for intent config (is_critical, task_description, fallback_key) |
| `system_context.yaml` | LLM system prompt (personality, rules) |
| `critical_templates.yaml` | Fixed templates (payments, validation) |
| `fallback_templates.yaml` | Backup when LLM fails |

**Usage Pattern** (Multi-tenant):
```python
from app.domains.pharmacy.agents.utils.response_generator import get_response_generator
from app.domains.pharmacy.agents.utils.exceptions import ResponseConfigNotFoundError

generator = get_response_generator()

# Generate response (requires db and organization_id)
response = await generator.generate(
    db=db_session,
    organization_id=organization_uuid,
    intent="greeting",
    state={"customer_name": "Juan", "pharmacy_name": "Farmacia XYZ"},
    user_message="Hola",
)
print(response.content)  # Generated message
print(response.response_type)  # LLM, CRITICAL, or FALLBACK
```

**Response Types**:
- `ResponseType.LLM`: Generated by LLM using system_context.yaml
- `ResponseType.CRITICAL`: Fixed template for payments/validation (never LLM)
- `ResponseType.FALLBACK`: Backup template when LLM fails/times out

**Rules**:
- **ALWAYS** pass `db` and `organization_id` to `generate()` methods
- Intent configuration MUST exist in database
- Missing config raises `ResponseConfigNotFoundError`
- Use Admin API to manage configurations

### 6. spaCy Intent Patterns - Database Only, NO Hardcoding

Intent patterns for spaCy MUST be stored in database, NOT hardcoded in Python files.

**Database Structure** (single table with JSONB columns):

```
core.domain_intents
‚îú‚îÄ‚îÄ id, organization_id, domain_key, intent_key
‚îú‚îÄ‚îÄ name, description, weight, exact_match, is_enabled, priority
‚îú‚îÄ‚îÄ lemmas: jsonb []              -- Array of strings ["deuda", "pagar", ...]
‚îú‚îÄ‚îÄ phrases: jsonb []             -- Array of {phrase, match_type}
‚îú‚îÄ‚îÄ confirmation_patterns: jsonb [] -- Array of {pattern, pattern_type}
‚îî‚îÄ‚îÄ keywords: jsonb []            -- Array of strings ["urgente", ...]
```

**Usage Pattern**:
```python
from app.core.cache.domain_intent_cache import domain_intent_cache

# Load patterns from database (with caching)
patterns = await domain_intent_cache.get_patterns(db, organization_id, "pharmacy")

# Access specific pattern types
intents = patterns["intents"]  # {intent_key: {lemmas, phrases, weight, exact_match}}
confirmations = patterns["confirmation_patterns"]  # {intent_key: {exact: set, contains: set}}
keywords = patterns["keyword_patterns"]  # {intent_key: [keywords]}
```

**Admin API**: `/api/v1/admin/intents/`

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/domains` | GET | List domains with intents |
| `/domains/{domain}/intents` | GET | List intents for domain |
| `/domains/{domain}/intents` | POST | Create intent |
| `/domains/{domain}/intents/{id}` | PUT | Update intent |
| `/domains/{domain}/intents/{id}` | DELETE | Delete intent |
| `/domains/{domain}/intents/{id}/lemmas` | POST/DELETE | Add/remove lemmas |
| `/domains/{domain}/intents/{id}/phrases` | POST/DELETE | Add/remove phrases |
| `/domains/{domain}/intents/{id}/keywords` | POST/DELETE | Add/remove keywords |
| `/domains/{domain}/intents/{id}/confirmation` | POST | Add confirmation patterns |
| `/cache/invalidate` | POST | Invalidate cache |
| `/cache/stats` | GET | Cache statistics |

**Rules**:
- NEVER add patterns to Python code (use database)
- Use `DomainIntentRepository` for database access
- Patterns are multi-tenant (per `organization_id`) and multi-domain (per `domain_key`)
- Cache has 3 layers: Memory (60s) ‚Üí Redis (5min) ‚Üí Database
- Use `domain_key="pharmacy"` for pharmacy domain patterns

### 7. Response Configuration - Database Only, NO Hardcoding

**CR√çTICO**: Toda la configuraci√≥n de respuestas del `PharmacyResponseGenerator` DEBE estar en base de datos. CERO hardcoding tolerado.

**Tabla**: `core.response_configs`

| Campo | Prop√≥sito | Reemplaza |
|-------|-----------|-----------|
| `intent_key` | Identificador √∫nico del intent | N/A |
| `is_critical` | Si usa plantilla fija (nunca LLM) | `CRITICAL_INTENTS` set (ELIMINADO) |
| `task_description` | Descripci√≥n de tarea para LLM | `_infer_task()` method (ELIMINADO) |
| `fallback_template_key` | Key de plantilla de respaldo | `_map_intent_to_fallback()` method (ELIMINADO) |

**Arquitectura de Cache** (3 niveles):
```
Memory (60s) ‚Üí Redis (5min) ‚Üí Database
```

**Uso Correcto**:
```python
from app.core.cache.response_config_cache import response_config_cache
from app.domains.pharmacy.agents.utils.exceptions import ResponseConfigNotFoundError

# Obtener configuraci√≥n - SIEMPRE debe existir
config = await response_config_cache.get_config(db, org_id, "greeting")
if config is None:
    raise ResponseConfigNotFoundError("greeting", org_id)

# Usar valores de configuraci√≥n
is_critical = config.is_critical
task = config.task_description
fallback_key = config.fallback_template_key
```

**Reglas OBLIGATORIAS**:
1. **NUNCA** agregar mappings hardcodeados en c√≥digo Python
2. **NUNCA** usar valores por defecto cuando no existe configuraci√≥n
3. **SIEMPRE** lanzar `ResponseConfigNotFoundError` si falta configuraci√≥n
4. **SIEMPRE** usar `ResponseConfigRepository` para acceso a DB
5. **SIEMPRE** invalidar cache despu√©s de modificar configuraci√≥n

**Admin API**: `/api/v1/admin/response-configs/`

| Endpoint | Method | Descripci√≥n |
|----------|--------|-------------|
| `/` | GET | Listar todas las configuraciones |
| `/` | POST | Crear configuraci√≥n |
| `/{config_id}` | GET | Obtener por ID |
| `/{config_id}` | PUT | Actualizar configuraci√≥n |
| `/{config_id}` | DELETE | Eliminar configuraci√≥n |
| `/by-intent/{intent_key}` | GET | Buscar por intent_key |
| `/bulk` | POST | Crear m√∫ltiples configuraciones |
| `/seed` | POST | Sembrar configuraciones por defecto |
| `/domains` | GET | Listar dominios con configs |
| `/cache/invalidate` | POST | Invalidar cache |
| `/cache/stats` | GET | Estad√≠sticas del cache |
| `/cache/warm` | POST | Calentar cache |

**Multi-domain Design**: La tabla y API soportan m√∫ltiples dominios via `domain_key` (default: "pharmacy"). Esto permite reutilizar la misma infraestructura para healthcare, ecommerce, etc. en el futuro.

### 8. REGLA GENERAL: CERO Hardcoding

**CR√çTICO**: NADA debe ir hardcodeado en el c√≥digo Python del dominio Pharmacy.

| Tipo de Dato | Tabla en DB | API Admin |
|--------------|-------------|-----------|
| Patterns, Lemmas, Phrases, Keywords | `core.domain_intents` | `/api/v1/admin/intents/` |
| Response configs (is_critical, task_description) | `core.response_configs` | `/api/v1/admin/response-configs/` |

**Reglas OBLIGATORIAS**:
```python
# ‚ùå PROHIBIDO - Cualquier forma de hardcoding
PATTERNS = ["pago", "deuda", ...]  # NO
LEMMAS = {"pay": "pagar", ...}  # NO
KEYWORDS = frozenset({"urgente", ...})  # NO
intent_mapping = {"greeting": ...}  # NO

# ‚úÖ CORRECTO - Siempre desde base de datos
from app.core.cache.domain_intent_cache import domain_intent_cache
patterns = await domain_intent_cache.get_patterns(db, org_id, "pharmacy")
```

**Si necesitas agregar patterns, lemmas, keywords o cualquier configuraci√≥n**:
1. **NUNCA** escribirlo en c√≥digo Python
2. **SIEMPRE** usar las APIs de administraci√≥n correspondientes
3. **SIEMPRE** invalidar cache despu√©s de modificar: `POST /cache/invalidate`

**Agregar nuevo intent**:
1. Insertar en `core.response_configs` via API o migraci√≥n
2. Agregar template en `fallback_templates.yaml` si es nuevo fallback_key
3. Invalidar cache: `POST /cache/invalidate`

**Errores Comunes**:
```python
# ‚ùå PROHIBIDO - Hardcoding
CRITICAL_INTENTS = {"payment_confirmation", ...}  # ELIMINADO

def _map_intent_to_fallback(self, intent):
    return {"greeting": "greeting"}.get(intent, "unknown")  # ELIMINADO

def _infer_task(self, intent):
    return {"greeting": "Saluda..."}.get(intent, "default")  # ELIMINADO

# ‚úÖ CORRECTO - Database driven
config = await response_config_cache.get_config(db, org_id, intent)
if not config:
    raise ResponseConfigNotFoundError(intent, org_id)
```

## Domain Structure

```
pharmacy/
‚îú‚îÄ‚îÄ agents/            # pharmacy_operations_agent
‚îú‚îÄ‚îÄ application/       # Use Cases, DTOs, Ports
‚îú‚îÄ‚îÄ domain/           # Entities, Value Objects, Domain Services
‚îú‚îÄ‚îÄ infrastructure/   # Repositories, External Services
‚îî‚îÄ‚îÄ services/         # Domain-specific services
```

## Architecture (Clean Architecture + DDD)

### Layer Structure

| Layer | Location | Contents |
|-------|----------|----------|
| **Domain** | `domain/` | Entities, Value Objects, Domain Services |
| **Application** | `application/` | Use Cases, DTOs, Ports (Protocol) |
| **Infrastructure** | `infrastructure/` | Repositories, External Services |

## Code Quality Standards

### SOLID Principles (Mandatory)

| Principle | Rule |
|-----------|------|
| **SRP** | One responsibility per class. Functions <20 lines. |
| **OCP** | Extend via inheritance, don't modify base. |
| **LSP** | Subclasses honor parent contracts. |
| **ISP** | Small, focused Protocol interfaces. |
| **DIP** | Depend on abstractions, inject dependencies. |

### Quality Rules
- **DRY**: Extract common logic, use base classes
- **KISS**: Simple solutions, no premature optimization
- **YAGNI**: Only implement current requirements

### Naming Conventions
- Classes: `PascalCase` (`PharmacyService`)
- Functions: `snake_case` (`get_medication`)
- Constants: `UPPER_SNAKE_CASE`
- Private: `_leading_underscore`

### Size Limits
- Functions: <20 lines (max 50)
- Classes: <200 lines (max 500)

## Development Patterns

### Adding Use Cases
1. Create in `application/use_cases/`
2. Define Port (Protocol) in `ports/`
3. Implement Repository in `infrastructure/repositories/`
4. Register in `DependencyContainer`
5. Add FastAPI dependency in `app/api/dependencies.py`

### Agent Template Method Pattern
```python
class PharmacyAgent(BaseAgent):
    async def _process_internal(self, state: dict) -> dict:
        # Your logic here - process() wrapper handles:
        # - Input validation
        # - Error handling with stack traces
        # - Metrics collection
        pass
```

## Code Review Checklist

- [ ] SRP: Single responsibility per class?
- [ ] Functions <20 lines?
- [ ] Dependencies injected?
- [ ] Type hints complete?
- [ ] Error handling with `from e`?
- [ ] Tests can run independently?
