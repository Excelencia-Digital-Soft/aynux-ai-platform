# ============================================================================
# SCOPE: MULTI-TENANT
# Description: Response generator orchestrator for pharmacy domain.
#              Coordinates template loading, LLM generation, and fallbacks.
# Tenant-Aware: Yes - each organization has its own configuration.
# ============================================================================
"""
Pharmacy Response Generator - Orchestrates response generation.

Uses specialized modules for:
- Template loading (PharmacyTemplateLoader)
- Template rendering (PharmacyTemplateRenderer)
- Configuration access (PharmacyConfigProvider)
- LLM invocation (PharmacyLLMProvider)

Response Types:
- LLM: Generated by LLM using system_context.yaml
- CRITICAL: Fixed template for payments/validation (never LLM)
- FALLBACK: Backup template when LLM fails/times out
"""

from __future__ import annotations

import asyncio
import logging
from dataclasses import dataclass
from enum import Enum, auto
from typing import TYPE_CHECKING, Any
from uuid import UUID

from app.domains.pharmacy.agents.utils.db_helpers import get_current_task
from app.integrations.llm import LLMError
from app.tasks import TaskRegistry

from .config_provider import PharmacyConfigProvider
from .llm_provider import PharmacyLLMProvider
from .template_loader import PharmacyTemplateLoader
from .template_renderer import PharmacyTemplateRenderer

if TYPE_CHECKING:
    from sqlalchemy.ext.asyncio import AsyncSession

logger = logging.getLogger(__name__)


class ResponseType(Enum):
    """Classification of response types."""

    LLM = auto()  # Generated by LLM
    CRITICAL = auto()  # Fixed template (legal, security)
    FALLBACK = auto()  # Backup when LLM fails


@dataclass
class GeneratedResponse:
    """Result of response generation."""

    content: str
    response_type: ResponseType
    intent: str
    error: str | None = None


class PharmacyResponseGenerator:
    """
    Orchestrator for pharmacy response generation.

    Single Responsibility: Coordinate response generation workflow.

    Uses dependency injection for all specialized modules.
    Multi-tenant: All operations require organization_id.
    """

    def __init__(
        self,
        template_loader: PharmacyTemplateLoader | None = None,
        template_renderer: PharmacyTemplateRenderer | None = None,
        config_provider: PharmacyConfigProvider | None = None,
        llm_provider: PharmacyLLMProvider | None = None,
    ) -> None:
        """
        Initialize response generator with optional dependencies.

        Args:
            template_loader: Template loader instance
            template_renderer: Template renderer instance
            config_provider: Config provider instance
            llm_provider: LLM provider instance
        """
        self._loader = template_loader or PharmacyTemplateLoader()
        self._renderer = template_renderer or PharmacyTemplateRenderer()
        self._config = config_provider or PharmacyConfigProvider()
        self._llm = llm_provider or PharmacyLLMProvider()

    async def generate(
        self,
        db: AsyncSession | None,
        organization_id: UUID,
        intent: str,
        state: dict[str, Any],
        user_message: str,
        current_task: str = "",
    ) -> GeneratedResponse:
        """
        Generate a response for the given intent and context.

        Args:
            db: AsyncSession for database access
            organization_id: Tenant UUID
            intent: Detected intent
            state: Current conversation state
            user_message: User's message
            current_task: Description of current task

        Returns:
            GeneratedResponse with content and metadata

        Raises:
            ResponseConfigNotFoundError: If intent config not found
        """
        templates = await self._loader.load()

        is_critical = await self._config.is_critical(db, organization_id, intent)
        if is_critical:
            return await self._get_critical_response(db, organization_id, intent, state, templates)

        try:
            return await self._generate_llm_response(
                db,
                organization_id,
                intent,
                state,
                user_message,
                current_task,
                templates,
            )
        except asyncio.TimeoutError:
            logger.warning("LLM timeout for intent '%s', using fallback", intent)
            return await self._get_fallback_response(db, organization_id, intent, state, templates, error="LLM timeout")
        except LLMError as e:
            logger.error("LLM error for intent '%s': %s", intent, e)
            return await self._get_fallback_response(db, organization_id, intent, state, templates, error=str(e))
        except Exception as e:
            logger.exception("Unexpected error generating response: %s", e)
            return await self._get_fallback_response(db, organization_id, intent, state, templates, error=str(e))

    async def _generate_llm_response(
        self,
        db: AsyncSession | None,
        organization_id: UUID,
        intent: str,
        state: dict[str, Any],
        user_message: str,
        current_task: str,
        templates: Any,
    ) -> GeneratedResponse:
        """Generate response using LLM with system context."""
        task_description = await self._config.get_task_description(db, organization_id, intent)
        effective_task = current_task if current_task else task_description

        variables = self._renderer.build_variables(intent, state, effective_task)
        system_prompt = self._renderer.render(templates.system_context, variables)

        messages = [
            ("system", system_prompt),
            ("human", user_message),
        ]

        response = await self._llm.invoke(messages)
        content = self._renderer.extract_content(response)

        return GeneratedResponse(
            content=content,
            response_type=ResponseType.LLM,
            intent=intent,
        )

    async def _get_critical_response(
        self,
        db: AsyncSession | None,
        organization_id: UUID,
        intent: str,
        state: dict[str, Any],
        templates: Any,
    ) -> GeneratedResponse:
        """Get fixed template response for critical intents."""
        fallback_key = await self._config.get_fallback_key(db, organization_id, intent)
        template = templates.critical_templates.get(fallback_key, "")

        if not template:
            logger.warning("No critical template for key: %s", fallback_key)
            return await self._get_fallback_response(
                db,
                organization_id,
                intent,
                state,
                templates,
                error="No critical template",
            )

        content = self._renderer.render(template, state)

        return GeneratedResponse(
            content=content,
            response_type=ResponseType.CRITICAL,
            intent=intent,
        )

    async def _get_fallback_response(
        self,
        db: AsyncSession | None,
        organization_id: UUID,
        intent: str,
        state: dict[str, Any],
        templates: Any,
        error: str | None = None,
    ) -> GeneratedResponse:
        """Get fallback template response."""
        fallback_key = await self._config.get_fallback_key(db, organization_id, intent)
        template = templates.fallback_templates.get(fallback_key, "")

        if not template:
            template = templates.fallback_templates.get(
                "unknown_intent",
                "Lo siento, no pude procesar tu solicitud. Intenta de nuevo.",
            )

        content = self._renderer.render(template, state)

        return GeneratedResponse(
            content=content,
            response_type=ResponseType.FALLBACK,
            intent=intent,
            error=error,
        )

    # =========================================================================
    # Convenience methods for common operations
    # =========================================================================

    async def generate_greeting(
        self,
        db: AsyncSession | None,
        organization_id: UUID,
        state: dict[str, Any],
        user_message: str,
    ) -> str:
        """Generate greeting response."""
        is_identified = bool(state.get("customer_name"))
        intent = "greeting_identified" if is_identified else "greeting"

        response = await self.generate(
            db=db,
            organization_id=organization_id,
            intent=intent,
            state=state,
            user_message=user_message,
            current_task=await get_current_task(TaskRegistry.PHARMACY_GREETING_DEFAULT),
        )
        return response.content

    async def generate_dni_request(
        self,
        db: AsyncSession | None,
        organization_id: UUID,
        state: dict[str, Any],
        user_message: str,
        is_welcome: bool = True,
    ) -> str:
        """Generate DNI request response."""
        intent = "request_dni_welcome" if is_welcome else "request_dni"

        response = await self.generate(
            db=db,
            organization_id=organization_id,
            intent=intent,
            state=state,
            user_message=user_message,
            current_task=await get_current_task(TaskRegistry.PHARMACY_IDENTIFICATION_REQUEST_IDENTIFIER),
        )
        return response.content

    async def generate_name_request(
        self,
        db: AsyncSession | None,
        organization_id: UUID,
        state: dict[str, Any],
        user_message: str,
    ) -> str:
        """Generate name request response."""
        response = await self.generate(
            db=db,
            organization_id=organization_id,
            intent="request_name",
            state=state,
            user_message=user_message,
            current_task=await get_current_task(TaskRegistry.PHARMACY_IDENTIFICATION_REQUEST_NAME),
        )
        return response.content

    async def generate_fallback(
        self,
        db: AsyncSession | None,
        organization_id: UUID,
        state: dict[str, Any],
        user_message: str,
        is_out_of_scope: bool = False,
    ) -> str:
        """Generate fallback response for unknown/out-of-scope."""
        intent = "out_of_scope" if is_out_of_scope else "unknown"

        response = await self.generate(
            db=db,
            organization_id=organization_id,
            intent=intent,
            state=state,
            user_message=user_message,
            current_task=await get_current_task(TaskRegistry.PHARMACY_FALLBACK_CAPABILITIES),
        )
        return response.content


# Singleton instance
_response_generator: PharmacyResponseGenerator | None = None


def get_response_generator() -> PharmacyResponseGenerator:
    """Get or create the singleton response generator instance."""
    global _response_generator
    if _response_generator is None:
        _response_generator = PharmacyResponseGenerator()
    return _response_generator


__all__ = [
    "GeneratedResponse",
    "PharmacyResponseGenerator",
    "ResponseType",
    "get_response_generator",
]
