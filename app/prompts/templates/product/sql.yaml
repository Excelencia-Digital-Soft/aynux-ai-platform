# Product SQL Generation Prompts
# Purpose: Prompts for dynamic SQL generation for product queries

prompts:
  - key: product.sql.complexity_analysis
    name: SQL Query Complexity Analysis
    description: Analyzes the complexity of user queries to optimize SQL generation
    version: "1.0.0"
    template: |
      # ANÁLISIS DE COMPLEJIDAD DE CONSULTA

      CONSULTA: "{user_query}"

      INTENCIÓN DETECTADA:
      {intent}

      Analiza la complejidad y responde en JSON:

      {
        "complexity_level": "simple|medium|complex|very_complex",
        "requires_joins": bool,
        "requires_aggregation": bool,
        "requires_subqueries": bool,
        "requires_full_text_search": bool,
        "tables_needed": ["products", "categories", "brands"],
        "estimated_query_type": "simple_select|filtered_search|aggregated_report|complex_analysis",
        "optimization_hints": ["índice_sugerido", "join_order"]
      }

      CRITERIOS:
      - simple: búsqueda básica por nombre/categoría
      - medium: filtros múltiples, joins básicos
      - complex: agregaciones, subqueries, full-text search
      - very_complex: múltiples joins, queries anidadas, análisis estadístico
    metadata:
      temperature: 0.2
      max_tokens: 400
      model: "deepseek-r1:7b"

  - key: product.sql.generation
    name: Product SQL Generation
    description: Generates optimized SQL queries for product searches
    version: "1.0.0"
    template: |
      # GENERACIÓN DE SQL PARA PRODUCTOS

      ## CONSULTA DEL USUARIO:
      "{user_query}"

      ## CONTEXTO DE INTENCIÓN:
      {intent_context}

      ## ANÁLISIS DE COMPLEJIDAD:
      {complexity}

      ## SCHEMA DE BASE DE DATOS:
      {schema_context}

      ## REGLAS IMPORTANTES:
      1. SOLO consultas SELECT permitidas
      2. Usar JOINS apropiados para relaciones
      3. Incluir filtros de productos activos (active = true)
      4. Optimizar para performance
      5. Limitar resultados a {max_results}
      6. Usar ILIKE para búsquedas de texto case-insensitive
      7. Manejar NULLs apropiadamente

      ## EJEMPLOS DE CONSULTAS TÍPICAS:

      Búsqueda simple:
      ```sql
      SELECT p.*, c.display_name as category_name, b.name as brand_name
      FROM products p
      LEFT JOIN categories c ON p.category_id = c.id
      LEFT JOIN brands b ON p.brand_id = b.id
      WHERE p.active = true AND p.name ILIKE '%keyword%'
      ORDER BY p.created_at DESC
      LIMIT {max_results};
      ```

      Búsqueda con filtros:
      ```sql
      SELECT p.*, c.display_name as category_name, b.name as brand_name
      FROM products p
      LEFT JOIN categories c ON p.category_id = c.id
      LEFT JOIN brands b ON p.brand_id = b.id
      WHERE p.active = true
        AND (p.name ILIKE '%keyword%' OR p.description ILIKE '%keyword%')
        AND c.name = 'categoria'
        AND p.price BETWEEN min_price AND max_price
        AND p.stock > 0
      ORDER BY p.price ASC
      LIMIT {max_results};
      ```

      ## INSTRUCCIONES:
      Genera UNA consulta SQL optimizada que responda exactamente a la consulta del usuario.
      Responde SOLO con el SQL, sin explicaciones.
    metadata:
      temperature: 0.1
      max_tokens: 800
      model: "deepseek-r1:7b"

  - key: product.sql.aggregation
    name: Product SQL Aggregation
    description: Generates SQL for aggregation queries (counts, sums, averages)
    version: "1.0.0"
    template: |
      # GENERACIÓN DE SQL DE AGREGACIÓN

      CONSULTA: "{user_query}"
      TIPO DE AGREGACIÓN: {aggregation_type}

      INTENCIÓN:
      {intent}

      Genera una consulta SQL que calcule agregaciones de productos.

      EJEMPLOS:
      - COUNT: SELECT COUNT(*) as total_products FROM products WHERE...
      - AVG: SELECT AVG(price) as average_price FROM products WHERE...
      - SUM: SELECT SUM(stock) as total_stock FROM products WHERE...
      - GROUP BY: SELECT category_name, COUNT(*) FROM products p JOIN categories c...

      Incluye JOINs necesarios y responde SOLO con el SQL:
    metadata:
      temperature: 0.1
      max_tokens: 600
